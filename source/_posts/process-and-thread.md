---
layout: post
title: 进程与线程
subtitle: Process and Thread
author: Hayden Wang
header-img: cpu.jpg
cdn: header-on
tags: [Computer Science]
date: 2018-02-26 21:45:29
---


## 摘要

1. 线程和进程的状态都有运行，就绪，阻塞状态
2. 进程有自己独立的内存地址空间，而线程共享进程的内存地址空间
3. 进程是组织资源的最小单位，而线程是安排CPU执行的最小单位


## 进程与线程的对比

### 1. 解构进程与线程

进程包含了线程、逻辑内存、文件/网络句柄。
线程包含了栈、PC（Program Control）指针：当前指令的内存地址、TLS（Thread Local Storage）：线程的独立内存

进程只是一个容器，线程才是真正运行的。

> 进程是具有一定独立功能的程序关于有个数据集合上的一次运行活动，是系统进行资源分配和调度的一个独立单元。

<p>

> 线程是进程的一个实体，是 CPU 调度和分派的基本单元，是比进程更小的能独立运行的基本单元。本身基本上不拥有系统资源，只用有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈）。一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。

线程和进程有很多相似之处，比如线程和进程的状态都有运行，就绪，阻塞状态。这几种状态理解起来非常简单，当进程所需的资源没有到位时会是阻塞状态，当进程所需的资源到位时但CPU没有到位时是就绪状态，当进程既有所需的资源，又有CPU时，就为运行状态。
进程有自己独立的内存地址空间，而线程共享进程的内存地址空间。
**进程是组织资源的最小单位，而线程是安排CPU执行的最小单位**。

### 2. 引入线程的好处

1.易于调度 2.提高并发性 3.开销小 4.发挥多核CPU性能

线程的好处如下:
1. 在很多程序中，需要多个线程互相同步或互斥的并行完成工作，而将这些工作分解到不同的线程中去无疑简化了编程模型。
2. 因为线程相比进程来说，更加的轻量，所以线程的创建和销毁的代价变得更小。
3. 线程提高了性能，虽然线程宏观上是并行的，但微观上却是串行。从CPU角度线程并无法提升性能，但如果某些线程涉及到等待资源（比如IO，等待输入）时，多线程允许进程中的其它线程继续执行而不是整个进程被阻塞，因此提高了CPU的利用率，从这个角度会提升性能。
4. 在多CPU或多核的情况下，使用线程不仅仅在宏观上并行，在微观上也是并行的。

### 3. 进程与线程的区别

进程(process)与线程(thread)最大的区别是: **进程拥有自己的地址空间**，某进程内的线程对于其他进程不可见，即进程 A 不能通过传地址的方式直接读写进程 B 的存储区域。进程之间的通信需要通过进程间通信(Inter-Process Communication，IPC)。与之相对的，同一进程的各线程间之间可以直接通过传递地址或全局变量的方式传递信息。

此外，**进程作为操作系统中拥有资源和独立调度的基本单位，可以拥有多个线程**。通常操作系统中运行的一个程序就对应一个进程。在同一进程中，线程的切换不会引起进程切换。在不同进程中进行线程切换，如从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。相比进程切换，线程切换的开销要小很多。线程于进程相互结合能够提高系统的运行效率。


---
<br>


## 进程

### 进程间通信

一个进程不能直接读写另一个进程的数据，两者之间的通信需要通过进程间通信进行。进程通信的方式通常遵**从生产者消费者模型**，需要实现数据交换和同步两大功能。

共享内存（Shared-Memory）+ Semaphore：不同进程通过读写操作系统中特殊的共享内存进行数据交换，进程之间用semaphore同步。
信息传递（Message Passing）：进程在操作系统内部注册一个窗口，并且检测有没有数据，其他进程直接读写数据到该窗口。


1. 文件 (File)：读写同一个文件。
2. 信号 (Signal)：一个进程给另一个进程发的信号，是个数字，用于控制。例如用 `kill -2 58249` 中断58249进程。除用于进程间通信外，进程还可以给自己发信号。
3. 管道 (Pipe) / 命名管道 (Named Pipe)：管道可用于具有亲缘关系的进程间通信。命名管道还允许无亲缘关系的进程间通信。例如用 `|` 串连起Linux的命令
4. 消息队列 (Message)：消息队列是消息的链表。有足够权限的进程可以写消息，有读权限的进程可以读消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺点
5. 共享内存 (Shared Memory)：多个进程访问同一块内存空间，是最快的可用IPC形式。针对其他通信机制效率低设计的，往往与信号量结合，用来达到进程间同步和互斥。
6. 信号量 (Semaphore)：进程间及统一进程不同线程间的同步手段。
7. 套接字 (Socket)：通过网络，可进行不同机器的进程间通信。


### 上下文切换

对于单核单线程 CPU 而言，在某一时刻只能执行一条 CPU 指令。**上下文切换(Context Switch)**是一种将CPU资源从一个进程分配给另一个进程的机制。从用户角度看，计算机能够并行运行多个进程，这恰恰是操作系统通过快速上下文切换造成的结果。在切换的过程中，操作系统需要先存储当前进程的状态(包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。

### 生产者消费者模型

生产者消费者模型是一种常见的通信模型:生产者和消费者共享一个数据管道，生产者将数据写入 buffer，消费者从另一头读取数据。对于数据管道，需要考虑为空和溢出的情况。同时，通常还需要将这部分共享内存用 mutex 加锁。在只有一个生产者一个消费者的情况下，可以设计无锁队列(lockless queue)，线程安全地直接读写数据。

### 调度算法

- 先来先服务算法 FCFS
- 短作业优先算法 SJF
- 优先级调度算法
- 高响应比优先算法
- 时间片轮转算法
- 多级反馈队列调度算法

---
<br>


## 线程

### 线程间同步

1. 临界区：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。
2. 互斥量：为协调对一个共享资源的单独访问而设计，只有拥有互斥量的线程才有权限访问。
3. 信号量：为控制一个具有有限数量的用户资源而设计，限制同一时刻访问资源的最大线程数目。
4. 事件：用来通知线程某事件已发生，从而启动后续任务。

### 线程的分类

线程可以分为两类：
1. 用户级线程（User Level Thread）：对于这类线程，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。在应用程序启动后，操作系统分配给该程序一个进程号，以及其对应的内存空间等资源。应用程序通常先在一个线程中运行，该线程称为主线程。在其运行的某个时刻，可以通过调用线程库中的函数创建一个在相同进程中运行的新线程。用户级线程的好处是非常高效，不需要进入内核空间，但并发效率不高。
2. 内核级线程（Kernel Level Thread）：对于这类线程，有关线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只能调用内核线程的接口。内核维护进程及其内部的每个线程，调度也由内核基于线程架构完成。内核级线程的好处是，内核可以将不同线程更好地分配到不同的CPU，以 实现真正的并行计算。

用户线程的优点：
1. 可以在不支持线程的操作系统中实现；
2. 创建、销毁、切换的代价比内核线程小得多；
3. 线程管理灵活，允许每个进程制定自己的调度算法；
4. 能利用的表空间和堆栈空间比内核线程多。

用户线程的缺点：
1. 统一进程中只能同时有一个线程运行，如果一个线程使用了系统调用而阻塞，整个进程都会被挂起；
2. 页面失效也会导致整个进程被挂起。

> 内核线程的优缺点刚好和用户线程相反。事实上，在现代操作系统中，往往使用组合方式实现多线程：即线程创建完全在用户空间中完成，并且一个应用程序中的多个用户级线程被映射到一些内核级线程上，相当于是一种折中方案。

### 线程池

为了解决创建线程开销大（相对进程来说）的问题，引入了线程池的概念。

> 线程池：预先建立好线程，等待任务派发。

包括两样东西：
1. 预先创建好的线程
2. 派发队列（Blocking Queue）

Java中线程池的参数：
- corePoolSize：线程池中初始线程数量，可能处于等待状态
- maximumPoolSize：线程池中最大允许线程数量
- keepAliveTime：超出corePoolSize部分线程如果等待这些时间将被回收


---
<br>


## 锁与死锁

### Semaphore / Mutex

当用户创立多个线程/进程时，如果不同线程/进程同时读写相同的内容，则 可能造成读写错误，或者数据不一致。此时，需要通过加锁的方式，控制核心区域(critical section)的访问权限。对于semaphore而言，在初始化变量的时候可以控制允许多少个线程/进程同时访问一个核心区域，其他的线程/进程会被堵塞，直到有人解锁。Mutex 相当于只允许一个线程/进程访问的 semaphore。

此外，根据实际需要，人们还实现了一种读写锁(read-write lock)，它允许同时存在多个读取者(reader)，但任何时候至多只有一个写入者(writer)，且不能与读取者共存。

### 死锁

在引入锁的同时，我们遇到了一个新的问题:死锁(Deadlock)。

> 死锁是指两个或多个线程/进程之间相互阻塞，以至于任何一个都不能继续运行，因此也不能解锁其他线程/进程。

所以说**死锁实际上就是多个进程因为争夺资源而造成的一种僵局**，若无外力作用，这些进程都无法向前推进。例如，线程 A 占有 lock A，并且尝试获取 lock B; 而线程 2 占有 lock B，尝试获取 lock A。此时，两者相互阻塞，都无法继续运行。

**产生死锁的必须同时满足四个条件**，任意一个不成立，死锁就不会发生: 
1. 互斥条件 Mutual Exclusion – Only one process may use a resource at a time 
2. 请求和保持条件 Hold-and-Wait – Process holds resource while waiting for another 
3. 不剥夺条件 No Preemption – Can’t take a resource away from a process
4. 循环等待条件 Circular Wait – The waiting processes form a cycle

**死锁处理策略**：
1. 预防死锁：设置某些限制条件，破坏四个条件中的一个或几个。
2. 避免思索：在资源的动态分配过程中，用某种方法纺织系统进入不安全状态。银行家算法是著名的死锁避免算法。
3. 死锁的检测及破除：通过系统的检测机制检测出死锁，并破除。破除方法有：(1)资源剥夺法 (2)撤销进程法 (3)进程回退法。


## References

- 进程和线程的区别：https://jingyan.baidu.com/article/624e74598efcc834e9ba5a66.html
- 操作系统中的线程与进程：http://www.cnblogs.com/CareySon/archive/2012/05/04/ProcessAndThread.html