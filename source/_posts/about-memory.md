---
layout: post
title: 内存那些事儿
subtitle: 关于操作系统的内存管理
author: Hayden Wang
header-img: memory.jpg
cdn: header-on
tags: [Computer Science]
date: 2018-02-26 22:47:30
---

## 计算机存储层次

硬盘 -> 内存 -> 缓存 -> 寄存器

寻址空间
32位 -> 4G
64位 -> 10^19 Bytes
64位JVM




寻址

指针指向逻辑内存，逻辑内存映射物理内存，物理内存不够用使用虚拟内存（分页载入）


## 逻辑地址和物理地址

所谓的逻辑地址，是指计算机用户(例如程序开发者)看到的地址。例如，当创建一个长度为 100 的整型数组时，操作系统返回一个逻辑上的连续空间: 指针指向数组第一个元素的内存地址。由于整型元素的大小为 4 个字节，故第二个元素的地址时起始地址加 4，以此类推。事实上，逻辑地址并不一定是元素存储的真实地址，即数组元素的物理地址(在内存条中所处的位置)，物理地址并不是连续的，只不过操作系统通过地址映射，将逻辑地址映射成连续的， 这样更符合人们的直观思维。

## 虚拟内存

另一个重要概念是虚拟内存。操作系统读写内存的速度可以比读写磁盘的速度快几个量级。但是，内存价格也相对较高，不能大规模扩展。于是，操作系统可以将部分不太常用的数据移出内存，存放到价格相对较低的磁盘缓存，以实现内存扩展。操作系统还可以通过算法预测哪部分存储到磁盘缓存的数据需要进行读写，提前把这部分数据读回内存。虚拟内存空间相对磁盘而言要小很多，因此，即使搜索虚拟内存空间也比直接搜索磁盘要快。唯一慢于磁盘的可能是，内存、虚拟内存中都没有所需要的数据，最终还需要从硬盘中直接读取。这就是为什么内存和虚拟内存中需要存储会被重复读写的数据，否则就失去了缓存的意义。

现代计算机中有一个专门的转译缓冲区(Translation Lookaside Buffer，TLB)，用来实现虚拟地址到物理地址的快速转换。

与内存/虚拟内存相关的还有以下两个概念: 
(1) Resident Set
当一个进程在运行的时候，操作系统不会一次性加载进程的所有数据到内存，只会加载一部分正在用，以及预期要用的数据。其他数据可能存储在虚拟内存，交换区和硬盘文件系统上。被加载到内存的部分就是 resident set。
(2) Thrashing
由于 resident set 包含预期要用的数据，理想情况下，进程运行过程中用到的数据都会逐步加载进resident set。但事实往往并非如此:每当需要的内存页面(page)不在 resident set 中时，操作系统必须从虚拟内存或硬盘中读数据，这个过程被称为内存页面错误(page faults)。当操作系统需要花费大量时间去处理页面错误的情况就是 thrashing。


## 堆 (Heap) 和栈 (Stack)

程序运行的时候，操作系统会给它分配一段内存，用来储存程序和运行产生的数据。这段内存有起始地址和结束地址，比如从 `0x1000` 到 `0x8000`，起始地址是较小的那个地址，结束地址是较大的那个地址。

![程序的内存分配](/images/os/memory_allocation.png)

### 内存中的堆 (Heap)

> 堆是用来存储动态分配变量的空间。对于堆而言，并没有像栈那样后进先出的规则，程序员可以选择随时分配或回收内存。这就意味着需要程序员自己用命令回收内存，否则会产生内存泄漏（memory leak）。在 C/C++中，程序员需要调用 free/delete 来释放动态分配的内存。 在 Java、Objective-C（with Automatic Reference Count）中，语言本身引入垃圾回收和计数规则帮助用户决定在什么时候自动释放内存。

程序运行过程中，对于动态的内存占用请求（比如新建对象，或者使用 `malloc` 命令），系统就会从预先分配好的那段内存之中，划出一部分给用户，具体规则是从起始地址开始划分（实际上，起始地址会有一段静态数据，这里忽略）。举例来说，用户要求得到10个字节内存，那么从起始地址 `0x1000` 开始给他分配，一直分配到地址 `0x100A`，如果再要求得到22个字节，那么就分配到 `0x1020`。

这种因为用户主动请求而划分出来的内存区域，叫做 Heap（堆）。**Heap 由起始地址开始，从低位（地址）向高位（地址）增长**。Heap 的一个重要特点就是不会自动消失，必须手动释放，或者由垃圾回收机制来回收。

### 内存中的栈 (Stack)

> 栈主要是指由操作系统自动管理的内存空间。当进入一个函数，操作系统会为该函数中的局部变量分配存储空间。事实上，系统会分配一个内存块，叠加在当前的栈上，并且利用指针指向前一个内存块的地址。函数的局部变量就存储在当前的内存块上。当该函数返回时，系统“弹出”内存块，并且根据指针回到前一个内存块。所以，栈总是以后进先出（LIFO）的方式工作。通常，在栈上分配的空间不需要用户操心。

除了 Heap 以外，其他的内存占用叫做 Stack（栈）。简单说，Stack 是由于函数运行而临时占用的内存区域。

**Stack 是由内存区域的结束地址开始，从高位（地址）向低位（地址）分配**。比如，内存区域的结束地址是 `0x8000`，第一帧假定是16字节，那么下一次分配的地址就会从 `0x7FF0` 开始；第二帧假定需要64字节，那么地址就会移动到 `0x7FB0`。
